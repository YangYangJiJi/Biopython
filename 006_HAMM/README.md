# 006_Counting Point Mutations
*rosalind id : HAMM

## 문제 이해 
- point mutation의 갯수 찾기.
- 두 동일길이 서열에서 Hamming distance를 구하는 것과 동일하다.

### 바이오 지식
- DNA 복제 과정에서 실수가 발생하면 돌연변이가 생길 수 있음.
- 돌연변이는 기본적으로 **실수(mistake)**이지만,매우 드물게 유익한 돌연변이가 발생할 수도 있고, 이것이 축적되면  **진화(evolution)**의 원동력이 됨.
- 실제로, 진화의 거대한 변화는 수 세대에 걸쳐 축적된 유익한 미세 돌연변이(microscopic mutations)의 결과로 설명됨.
- point mutation는 DNA 서열에서 특정 염기(nucleotide)가 다른 염기로 바뀌는 돌연변이를 의미함.
- 서로 다른 생물 종 또는 개체에서 추출한 두 개의 DNA 서열이 같은 조상을 공유하면 이를 **상동 서열(homologous strands)**이라 부름.
- 상동 서열에서 염기가 다른 위치의 개수를 세면,진화 과정에서 최소한 몇 번의 점 돌연변이가 발생했는지 알 수 있음.
- 즉, 해밍 거리(Hamming Distance) = 최소한의 점 돌연변이 개수.
- **최소 변화의 원칙(Parsimony Principle)**이란,
진화적 변화는 최대한 단순하게 설명되어야 한다는 개념.
- 따라서, 서로 다른 종의 DNA 서열을 비교하여 최소한의 돌연변이로 진화적 관계를 설명하려고 함.
- 즉,  해밍 거리를 계산하면 두 생물 간의 유전적 차이를 측정할 수 있고, 최소한의 돌연변이로 진화적 관계를 설명할 수 있음!!!

### 핵심개념 : Hamming distance
- 두 개의 같은 길이를 가진 문자열에서 위치별로 다른 문자의 개수를 의미함.
- 즉, 두 문자열을 일치시키기 위해 최소한 몇 개의 문자를 바꿔야 하는지를 계산하는 것.

### input data
```
GAGCCTACTAACGGGAT
CATCGTAATGACGGCCT
```
- 동일한 길이의 두 DNA 서열 (최대 100bp)

### output data
```
7
```
- 서로 다른 문자개수가 7개 이므로, Hammng Distance도 7이다. 

### 핵심 아이디어
- 두 문자열을 같은 인덱스에서 비교하여 다른 문자 개수를 세기
- Hamming Distance는 단순한 비교로 계산 가능하므로 O(n)의 시간 복잡도로 해결 가능
- 즉 `서열1[i] ≠ 서열2[i]`인 경우를 세면 정답

### 힌트
1. 두 문자열을 같은 인덱스에서 비교해야 함.
    - `s[i] ≠ t[i]`이면 Hamming Distance +1 증가.
    - `zip(s, t)`을 사용하면 두 문자열을 쉽게 한 쌍씩 비교 가능!
2. 반복문을 사용하여 문자 비교
    - for 루프를 사용해서 s[i]와 t[i]를 하나씩 비교하면 됨.
3. Hamming Distance를 카운트
    - 다른 문자의 개수를 세면 됨 
    - `sum(1 for a, b in zip(s, t) if a != b)`

## 파이썬 공부

### zip() 함수
- 한마디로 데이터를 묶는 함수
- 여러 개의 리스트/튜플을 하나씩 묶어서 이터레이터(iterator)를 반환하는 함수.
- iterable 자료형을 인자로 받고, 각 자료형의 각각의 요소를 나눈 후, 인덱스끼리 잘라서 리스트로 반환 해준다. (`zip(iterable)`형태)
- 참고로 iterable 자료형은 파이썬에서 리스트, 튜플 같은 반복 가능한 자료형을 의미함.
- 함수를 넘길 때, 인자의 길이를 똑같이 해야함을 주의하자.
*출처 : https://wjunsea.tistory.com/106

*** zip() 기본문법 ***
```
list1 = [1, 2, 3, 4]
list2 = ['one', 'two', 'three', 'four']

# 인덱스를 사용하여 같은 값이 나오게 구현
for x, y in zip(list1, list2) :
    print(x,y)
```
```
# 인덱스가 같은 요소를 나눈 후 묶어줌
for i in range(4) :
    print(list1[i], list2[i])
```
- 두 코드의 결과로는 둘다 다음처럼 나온다.
```
1 one
2 two
3 three
4 four
```

*** zip() 사용예시 ***
- zip()함수를 이용하면 여러 iterable 객체를 2개 이상 넘겨 처리할 수 있음
```
a = "12345"
b = "qwert"
c = "asdfg"

for x, y, z in zip(a,b,c) :
    print(x,y,z)
```
```
1 q a
2 w s
3 e d
4 r f
5 t g
```

*** zip()과 딕셔너리의 차이 ***
뭔가 둘다 데이터를 묶어준다는 느낌이 비슷해서 비교를 해봤다.
- 데이터 저장 측면
    - zip() : 저장하지 않고, 즉시 사용
    - dict() : 키-값 형태로 저장
- 빠른 검색 측면
    - zip() : 제공하지 않음
    - dict() : dict[key]로 빠르게 접근
- 순차적 사용 측면
    - zip() :for 루프로 반복 접근 가능
    - dict() : 키를 기반으로 반복 가능

### 코드에서 zip() 활용
```
s = "GAGCCT"
t = "CATCGT"

for a, b in zip(s, t):
    print(a, b)
```
```
G C
A A
G T
C C
C G
T T
```
- zip(s, t)는 s와 t의 각 문자들을 같은 위치끼리 쌍으로 묶어서 반환함.
- 따라서 a, b는 s[i]와 t[i]를 의미한다고 보면 됨

### input data를 줄 단위로 분리
- splitlines() 또는 
- readlines() + strip()을 사용하여 줄 단위로 분리
- 후에 각각 s, t 변수에 저장 후 활용가능

### O(n) 알고리즘
- O(n) 알고리즘은 입력 항목 수에 비례하여 실행 시간이 증가하는 알고리즘
- 이 문제에서는 문자열 길이가 최대 1000bp이므로 O(n) 알고리즘이면 충분히 빠름
- 만약 서열 길이가 1000bp보다 더 길어진다면 성능 저하될 가능성 있음.

### 빅오 표기법
- O(1), O(N), O(logN) 이 있다.
- 컴퓨터 과학자는 시간 복잡도를 쉽게 소통할 목적으로 자료 구조와 알고리즘의 효율성을 간결하고 일관된 언어로 설명하기 위해 수학적 개념을 차용했다. 이러한 개념을 형식화한 표현을 빅 오 표기법이라고 부른다.
- '알고리즘 수행에 필요한 단계 수'가 알고리즘의 효율성을 결정하는 주된 요인이다.
1. O(N) : 완벽한 대각선을 그린다. 데이터가 하나씩 추가될 때마다 알고리즘이 한 단계씩 더 걸리기 때문이다. 따라서 데이터가 많아질수록 알고리즘에 필요한 단계 수도 늘어난다.
2. O(1) : 완벽한 수평선을 그린다. 데이터의 증가나 감소에 영향 받지 않고 단계 수가 일정하다.
3. O(logN) : 데이터가 두 배로 증가할 때마다 한 단계씩 늘어나는 알고리즘